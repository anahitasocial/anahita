<?php
/**
 * @version 	$Id: identifiable.php 4628 2012-05-06 19:56:43Z johanjanssens $
 * @package		Koowa_Database
 * @subpackage 	Behavior
 * @copyright	Copyright (C) 2007 - 2012 Johan Janssens. All rights reserved.
 * @license		GNU GPLv3 <http://www.gnu.org/licenses/gpl.html>
 */

/**
 * Database Identifiable Behavior
 *
 * @author		Johan Janssens <johan@nooku.org>
 * @package     Koowa_Database
 * @subpackage 	Behavior
 */
class KDatabaseBehaviorIdentifiable extends KDatabaseBehaviorAbstract
{
    /**
     * Set to true if uuid should be autogenerated on select if it doesn't exist. 
     *
     * @var boolean
     */
    protected $_auto_generate;
    
    /**
     * Constructor.
     *
     * @param   object  An optional KConfig object with configuration options
     */
    public function __construct( KConfig $config = null)
    {
        parent::__construct($config);
    
        foreach($config as $key => $value)
        {
            if(property_exists($this, '_'.$key)) {
                $this->{'_'.$key} = $value;
            }
        }
    }
    
    /**
     * Initializes the options for the object
     *
     * Called from {@link __construct()} as a first step of object instantiation.
     *
     * @param 	object 	An optional KConfig object with configuration options
     * @return void
     */
    protected function _initialize(KConfig $config)
    {
        $config->append(array(
    		'auto_generate'  => true,
        ));
    
        parent::_initialize($config);
    }
	
	/**
	 * Get the methods that are available for mixin based
	 * 
	 * This function conditionaly mixes of the behavior. Only if the mixer 
	 * has a 'uuid' property the behavior will be mixed in.
	 * 
	 * @param object The mixer requesting the mixable methods. 
	 * @return array An array of methods
	 */
	public function getMixableMethods(KObject $mixer = null)
	{
		$methods = array();
		
		if(isset($mixer->uuid)) {
			$methods = parent::getMixableMethods($mixer);
		}
    
		return $methods;
	}
	
	/**
	* Auto generated the uuid
	*
	* If the row exists and doesn't have a valid 'uuid' value auto generate it.
	* 
	* Requires an 'uuid' column, if the column type is char the uuid will be
	* a string, if the column type is binary a hex value will be returned.
	*
	* @return void
	*/
	protected function _afterTableSelect(KCommandContext $context)
	{
	    if($this->_auto_generate && !$this->isNew())
	    {  
	        if(isset($this->uuid) && empty($this->uuid)) 
	        {
	            $hex = $this->getTable()->getColumn('uuid')->type == 'char' ? false : true;
	            $this->uuid  = $this->_uuid($hex);
	        
	            $this->save();
	        }
	    }
	}
	
	/**
	* Set uuid information
	*
	* Requires an 'uuid' column, if the column type is char the uuid will be
	* a string, if the column type is binary a hex value will be returned.
	*
	* @return void
	*/
	protected function _beforeTableInsert(KCommandContext $context)
	{
		if(isset($this->uuid)) 
		{
			$hex = $this->getTable()->getColumn('uuid')->type == 'char' ? false : true;
			$this->uuid  = $this->_uuid($hex);
		}
	}
	
	/**
     * Generates a Universally Unique IDentifier, version 4.
     *
     * This function generates a truly random UUID.
     *
     * @param boolean	If TRUE return the uuid in hex format, otherwise as a string
     * @see http://tools.ietf.org/html/rfc4122#section-4.4
     * @see http://en.wikipedia.org/wiki/UUID
     * @return string A UUID, made up of 36 characters or 16 hex digits.
     */
    protected function _uuid($hex = false) 
    {
        $pr_bits = false;
        
        $fp = @fopen ( '/dev/urandom', 'rb' );
        if ($fp !== false) 
        {
            $pr_bits = @fread ( $fp, 16 );
            @fclose ( $fp );
        } 
        
         // If /dev/urandom isn't available (eg: in non-unix systems), use mt_rand().
        if(empty($pr_bits)) 
        {
            $pr_bits = "";
            for($cnt = 0; $cnt < 16; $cnt ++) {
                $pr_bits .= chr ( mt_rand ( 0, 255 ) );
            }
        }
        
        $time_low = bin2hex ( substr ( $pr_bits, 0, 4 ) );
        $time_mid = bin2hex ( substr ( $pr_bits, 4, 2 ) );
        $time_hi_and_version = bin2hex ( substr ( $pr_bits, 6, 2 ) );
        $clock_seq_hi_and_reserved = bin2hex ( substr ( $pr_bits, 8, 2 ) );
        $node = bin2hex ( substr ( $pr_bits, 10, 6 ) );
       
        /**
         * Set the four most significant bits (bits 12 through 15) of the
         * time_hi_and_version field to the 4-bit version number from
         * Section 4.1.3.
         * @see http://tools.ietf.org/html/rfc4122#section-4.1.3
         */
        $time_hi_and_version = hexdec ( $time_hi_and_version );
        $time_hi_and_version = $time_hi_and_version >> 4;
        $time_hi_and_version = $time_hi_and_version | 0x4000;
       
        /**
         * Set the two most significant bits (bits 6 and 7) of the
         * clock_seq_hi_and_reserved to zero and one, respectively.
         */
        $clock_seq_hi_and_reserved = hexdec ( $clock_seq_hi_and_reserved );
        $clock_seq_hi_and_reserved = $clock_seq_hi_and_reserved >> 2;
        $clock_seq_hi_and_reserved = $clock_seq_hi_and_reserved | 0x8000;
       
        //Either return as hex or as string
        $format = $hex ? '%08s%04s%04x%04x%012s' : '%08s-%04s-%04x-%04x-%012s';
        
        return sprintf ( $format, $time_low, $time_mid, $time_hi_and_version, $clock_seq_hi_and_reserved, $node );
    }
    
}